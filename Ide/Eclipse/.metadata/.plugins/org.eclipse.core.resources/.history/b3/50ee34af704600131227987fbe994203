//
// Tizen C++ SDK
// Copyright (c) 2012-2013 Samsung Electronics Co., Ltd.
//
// Licensed under the Flora License, Version 1.1 (the License);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://floralicense.org/license/
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an AS IS BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#include <FIo.h>
#include <math.h>
#include "GlesShader.h"


using namespace Tizen::App;
using namespace Tizen::Base;
using namespace Tizen::Base::Runtime;
using namespace Tizen::Base::Utility;
using namespace Tizen::System;
using namespace Tizen::Ui;
using namespace Tizen::Ui::Controls;
using namespace Tizen::Graphics;
using namespace Tizen::Graphics::Opengl;


const int TIME_OUT = 10;
const int PAUSE_TIME = 100;
const double PI = 3.1415926535897932384626433832795;

extern const float VERTEX_ATTRIBUTES[];
extern const unsigned short INDICES[];
extern const unsigned int MAX_V_COUNT;
extern const unsigned int MAX_F_COUNT;

class GlesForm
	: public Tizen::Ui::Controls::Form
{
public:
	GlesForm(GlesShader* pApp)
		: __pApp(pApp)
	{
	}

	virtual ~GlesForm(void)
	{
	}

	virtual result OnDraw(void)
	{
		if (__pApp != null)
		{
			__pApp->Draw();
		}
		return E_SUCCESS;
	}

private:
	GlesShader* __pApp;
};

GlesShader::GlesShader(void)
	: __pForm(null)
	, __eglDisplay(EGL_NO_DISPLAY)
	, __eglSurface(EGL_NO_SURFACE)
	, __eglConfig(null)
	, __eglContext(EGL_NO_CONTEXT)
	, __programObject(0)
	, __idxVPosition(0)
	, __idxVNormal(0)
	, __idxVBO(0)
	, __idxIBO(0)
	, __idxLightDir(0)
	, __idxMVP(0)
	, __pTimer(null)
	, __idxTimeStamp(0)
	, __timeStamp(1)
	, __strideTimeStamp(0.02 * PI)
	, __stopCount(-1)
	, __angle(0.0f)
{
	__axis[0] = 1.0f;
	__axis[1] = 0.0f;
	__axis[2] = 0.0f;
}

GlesShader::~GlesShader(void)
{
}

void
GlesShader::Cleanup(void)
{
	if (__pTimer != null)
	{
		__pTimer->Cancel();
		delete __pTimer;
		__pTimer = null;
	}

	DestroyGL();
}

Application*
GlesShader::CreateInstance(void)
{
	// Create the instance through the constructor.
	return new (std::nothrow) GlesShader();
}

bool
GlesShader::OnAppInitializing(AppRegistry& appRegistry)
{
	result r = E_SUCCESS;

	Frame* pAppFrame = new (std::nothrow) Frame();
	TryReturn(pAppFrame != null, E_FAILURE, "[GlesShader] Generating a frame failed.");

	r = pAppFrame->Construct();
	TryReturn(!IsFailed(r), E_FAILURE, "[GlesShader] pAppFrame->Construct() failed.");

	this->AddFrame(*pAppFrame);

	__pForm = new (std::nothrow) GlesForm(this);
	TryCatch(__pForm != null, , "[GlesShader] Allocation of GlesForm failed.");

	r = __pForm->Construct(FORM_STYLE_NORMAL);
	TryCatch(!IsFailed(r), delete __pForm, "[GlesShader] __pForm->Construct(FORM_STYLE_NORMAL) failed.");

	r = GetAppFrame()->GetFrame()->AddControl(__pForm);
	TryCatch(!IsFailed(r), delete __pForm, "[GlesShader] GetAppFrame()->GetFrame()->AddControl(__pForm) failed.");

	__pForm->AddKeyEventListener(*this);

	TryCatch(InitEGL(), , "[GlesShader] GlesCube::InitEGL() failed.");

	TryCatch(InitGL(), , "[GlesShader] GlesCube::InitGL() failed.");

	GenerateVBO();
	Update();

	__pTimer = new (std::nothrow) Timer;
	TryCatch(__pTimer != null, , "[GlesShader] Failed to allocate memory.");

	r = __pTimer->Construct(*this);
	TryCatch(!IsFailed(r), , "[GlesShader] __pTimer->Construct(*this) failed.");

	return true;

CATCH:
	AppLog("[GlesShader] GlesShader::OnAppInitializing eglError : %#x\n"
			"[GlesShader] GlesShader::OnAppInitializing glError : %#x\n"
			"[GlesShader] GlesShader::OnAppInitializing VENDOR : %s\n"
			"[GlesShader] GlesShader::OnAppInitializing GL_RENDERER : %s\n"
			"[GlesShader] GlesShader::OnAppInitializing GL_VERSION : %s\n ",
			static_cast<unsigned int>(eglGetError()),
			static_cast<unsigned int>(glGetError()),
			glGetString(GL_VENDOR),
			glGetString(GL_RENDERER),
			glGetString(GL_VERSION));

	Cleanup();

	return false;
}

bool
GlesShader::OnAppTerminating(AppRegistry& appRegistry, bool forcedTermination)
{
	Cleanup();

	return true;
}

void
GlesShader::OnForeground(void)
{
	if (__pTimer != null)
	{
		__pTimer->Start(TIME_OUT);
	}
}

void
GlesShader::OnBackground(void)
{
	if (__pTimer != null)
	{
		__pTimer->Cancel();
	}
}

void
GlesShader::OnLowMemory(void)
{
}

void
GlesShader::OnBatteryLevelChanged(BatteryLevel batteryLevel)
{
}

void
GlesShader::OnScreenOn(void)
{
}

void
GlesShader::OnScreenOff(void)
{
}

void
GlesShader::OnTimerExpired(Timer& timer)
{
	if (__pTimer == null)
	{
		return;
	}
	__pTimer->Start(TIME_OUT);

	IncTimeStamp();

	Update();

	if (!Draw())
	{
		AppLog("[MeshLoader] MeshLoader::Draw() failed.");
	}
}

void
GlesShader::OnKeyPressed(const Control& source, Tizen::Ui::KeyCode keyCode)
{
}

void
GlesShader::OnKeyReleased(const Control& source, Tizen::Ui::KeyCode keyCode)
{
	if (keyCode == Tizen::Ui::KEY_BACK || keyCode == Tizen::Ui::KEY_ESC)
	{
		Terminate();
	}
}

void
GlesShader::OnKeyLongPressed(const Control& source, Tizen::Ui::KeyCode keyCode)
{
}

void
GlesShader::DestroyGL(void)
{
	DeleteVBO();

	if (__programObject)
	{
		glDeleteProgram(__programObject);
	}

	if (__eglDisplay)
	{
		eglMakeCurrent(__eglDisplay, null, null, null);

		if (__eglContext)
		{
			eglDestroyContext(__eglDisplay, __eglContext);
			__eglContext = EGL_NO_CONTEXT;
		}

		if (__eglSurface)
		{
			eglDestroySurface(__eglDisplay, __eglSurface);
			__eglSurface = EGL_NO_SURFACE;
		}

		eglTerminate(__eglDisplay);
		__eglDisplay = EGL_NO_DISPLAY;
	}

	return;
}

bool
GlesShader::InitEGL(void)
{
	EGLint numConfigs = 1;

	EGLint eglConfigList[] =
	{
		EGL_RED_SIZE,	8,
		EGL_GREEN_SIZE,	8,
		EGL_BLUE_SIZE,	8,
		EGL_ALPHA_SIZE,	0,
		EGL_DEPTH_SIZE, 8,
		EGL_SURFACE_TYPE, EGL_WINDOW_BIT,
		EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
		EGL_NONE
	};

	EGLint eglContextList[] =
	{
		EGL_CONTEXT_CLIENT_VERSION, 2,
		EGL_NONE
	};

	eglBindAPI(EGL_OPENGL_ES_API);

	__eglDisplay = eglGetDisplay((EGLNativeDisplayType)EGL_DEFAULT_DISPLAY);
	TryCatch(__eglDisplay != EGL_NO_DISPLAY, , "[GlesShader] eglGetDisplay() failed.");

	TryCatch(!(eglInitialize(__eglDisplay, null, null) == EGL_FALSE || eglGetError() != EGL_SUCCESS), , "[GlesShader] eglInitialize() failed.");

	TryCatch(!(eglChooseConfig(__eglDisplay, eglConfigList, &__eglConfig, 1, &numConfigs) == EGL_FALSE ||
			eglGetError() != EGL_SUCCESS), , "[GlesShader] eglChooseConfig() failed.");

	TryCatch(numConfigs, , "[GlesShader] eglChooseConfig() failed. because of matching config doesn't exist");

	__eglSurface = eglCreateWindowSurface(__eglDisplay, __eglConfig, (EGLNativeWindowType)__pForm, null);
	TryCatch(!(__eglSurface == EGL_NO_SURFACE || eglGetError() != EGL_SUCCESS), , "[GlesShader] eglCreateWindowSurface() failed.");

	__eglContext = eglCreateContext(__eglDisplay, __eglConfig, EGL_NO_CONTEXT, eglContextList);
	TryCatch(!(__eglContext == EGL_NO_CONTEXT || eglGetError() != EGL_SUCCESS), , "[GlesShader] eglCreateContext() failed.");

	TryCatch(!(eglMakeCurrent(__eglDisplay, __eglSurface, __eglSurface, __eglContext) == EGL_FALSE ||
			eglGetError() != EGL_SUCCESS), , "[GlesShader] eglMakeCurrent() failed.");

	return true;

CATCH:
	{
		AppLog("[GlesShader] GlesShader can run on systems which supports OpenGL ES(R) 2.0.");
		AppLog("[GlesShader] When GlesShader does not correctly execute, there are a few reasons.");
		AppLog("[GlesShader]    1. The current device(real-target or emulator) does not support OpenGL ES(R) 2.0.\n"
				" Check the Release Notes.");
		AppLog("[GlesShader]    2. The system running on emulator cannot support OpenGL(R) 2.1 or later.\n"
				" Try with other system.");
		AppLog("[GlesShader]    3. The system running on emulator does not maintain the latest graphics driver.\n"
				" Update the graphics driver.");
	}

	DestroyGL();

	return false;
}

bool
GlesShader::InitGL(void)
{
	GLint linked = GL_FALSE;

	glEnable(GL_DEPTH_TEST);

	glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	return true;
}

void
GlesShader::GenerateVBO(void)
{
	glGenBuffers(1, &__idxVBO);
	glBindBuffer(GL_ARRAY_BUFFER, __idxVBO);
	glBufferData(GL_ARRAY_BUFFER, 6 * sizeof(float) * MAX_V_COUNT, VERTEX_ATTRIBUTES, GL_STATIC_DRAW);

	glGenBuffers(1, &__idxIBO);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, __idxIBO);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, 3 * sizeof(GLushort) * MAX_F_COUNT, INDICES, GL_STATIC_DRAW);
}

void
GlesShader::DeleteVBO(void)
{
	glDeleteBuffers(1, &__idxVBO);
	glDeleteBuffers(1, &__idxIBO);
}

void
GlesShader::Update(void)
{
	FloatMatrix4 matPerspective;
	FloatMatrix4 matModelview;

	const float EPSILON = 0.5f;

	if (__stopCount < 0)
	{
		__angle += 1.0f;

		if (__angle >= 360.0f)
		{
			__angle -= 360.0f;
		}

		float	remain = __angle - 90 * static_cast<float>(static_cast<int>(__angle / 90));

		if (remain > -EPSILON && remain < EPSILON)
		{
			__stopCount = 0;
		}
	}
	else
	{
		__stopCount++;

		if (__stopCount == PAUSE_TIME)
		{
			__stopCount = -1;
		}
	}

	int x, y, width, height;
	__pForm->GetBounds(x, y, width, height);

	float aspect = float(width) / float(height);

	Perspective(&matPerspective, 60.0f, aspect, 1.0f, 20.0f);

	Translate(&matModelview, 0.0f, 0.0f, -2.5f);
	Rotate(&matModelview, __angle, __axis[0], __axis[1], __axis[2]);

	__matMVP = matPerspective * matModelview;
}


void
GlesShader::IncTimeStamp(void)
{
	__timeStamp += __strideTimeStamp;

	if (__timeStamp > 2 * PI)
	{
		__timeStamp = 0;
	}
}

bool
GlesShader::Draw(void)
{
	if (eglMakeCurrent(__eglDisplay, __eglSurface, __eglSurface, __eglContext) == EGL_FALSE ||
			eglGetError() != EGL_SUCCESS)
	{
		AppLog("[GlesShader] eglMakeCurrent() failed.");

		return false;
	}

	int x, y, width, height;
	__pForm->GetBounds(x, y, width, height);

	glViewport(0, 0, width, height);

	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glUniform4fv(__idxLightDir, 1, __lightDir);
	glUniformMatrix4fv(__idxMVP, 1, GL_FALSE, (GLfloat*)__matMVP.matrix);
	glUniform1f(__idxTimeStamp, __timeStamp);

	glBindBuffer(GL_ARRAY_BUFFER, __idxVBO);
	glVertexAttribPointer(__idxVPosition, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), static_cast<char*>(null) + 0);
	glEnableVertexAttribArray(__idxVPosition);
	glVertexAttribPointer(__idxVNormal, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), static_cast<char*>(null) + (3 * sizeof(float)));
	glEnableVertexAttribArray(__idxVNormal);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, __idxIBO);
	glDrawElements(GL_TRIANGLES, 3 * MAX_F_COUNT, GL_UNSIGNED_SHORT, static_cast<char*>(null) + 0);

	eglSwapBuffers(__eglDisplay, __eglSurface);

	glDisableVertexAttribArray(__idxVPosition);
	glDisableVertexAttribArray(__idxVNormal);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

	return true;
}
